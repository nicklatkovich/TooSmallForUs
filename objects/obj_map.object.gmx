<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
PlanetsAvailable = 4;
PlanetsUsed = 1;

randomize( );

CellSize = 64;
CellW = CellSize * 2.0;
CellH = sqrt(3.0) * CellSize / 2.0;
CellH2 = CellH * 2.0;

PlanetInfo = false;

Drag = false;

Width = floor(room_width / CellW - 0.5);
Height = floor(room_height / CellH2);
Width = 24;//floor(room_width / CellW - 0.5);
Height = 24;//floor(room_height / CellH2);

Grid = ds_grid_create(Width, Height);
ds_grid_clear(Grid, 0);

VisGrid = ds_grid_create(Width, Height);
ds_grid_clear(VisGrid, 0);

x_start = irandom(Width - 1);
y_start = irandom(Height - 1);
Grid[#x_start,y_start] = 1;
var qx;
var qy;
var q_size = 1;
qx[0] = x_start;
qy[0] = y_start;

Scale = 1;
PosX = x_start * obj_map.CellW + obj_map.CellSize * (y_start % 2) + obj_map.CellSize - room_width / 2.0 / Scale;
PosY = y_start * obj_map.CellH2 + obj_map.CellH - room_height / 2.0 / Scale;

VisGrid[#x_start,y_start] = 2;
for (var d = 0; d &lt; 6; d++) {
    var xx = x_start + hex_dx(x_start, y_start, d);
    var yy = y_start + hex_dy(d);
    if (xx &gt;= 0 &amp;&amp; xx &lt; Width &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; Height) {
        VisGrid[#xx,yy] = 2;
    }
}
for (var d = 0; d &lt; 12; d++) {
    var xx = x_start + hex_ddx(x_start, y_start, d);
    var yy = y_start + hex_ddy(d);
    if (xx &gt;= 0 &amp;&amp; xx &lt; Width &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; Height) {
        VisGrid[#xx,yy] = 1;
    }
}

while (q_size &gt; 0) {
    var q = irandom(q_size - 1);
    var xx = qx[q];
    var yy = qy[q];
    q_size--;
    qx[q] = qx[q_size];
    qy[q] = qy[q_size];
    if (Grid[#xx,yy] == 1) {
        Grid[#xx,yy] = 2;
        for (var d = 0; d &lt; 6; d++) {
            var xt = xx + hex_dx(xx, yy, d);
            var yt = yy + hex_dy(d);
            if (xt &gt;= 0 &amp;&amp; xt &lt; Width &amp;&amp; yt &gt;= 0 &amp;&amp; yt &lt; Height) {
                Grid[#xt,yt] = 3;
            }
        }
        for (var d = 0; d &lt; 12; d++) {
            var xt = xx + hex_ddx(xx, yy, d);
            var yt = yy + hex_ddy(d);
            if (xt &gt;= 0 &amp;&amp; xt &lt; Width &amp;&amp; yt &gt;= 0 &amp;&amp; yt &lt; Height) {
                switch (Grid[#xt,yt]) {
                case 0:
                    qx[q_size] = xt;
                    qy[q_size] = yt;
                    q_size++;
                    Grid[#xt,yt] = 1;
                    break;
                }
            }
        }
    }
}

/*
var c = instance_create(getPosX(x_start, y_start) / Scale + PosX, getPosY(x_start, y_start) / Scale + PosY, obj_creep);
c.xx = x_start;
c.yy = y_start;
*/
FPSOut = "";
alarm[0] = 20;

breaf = noone;

instance_create(0, 0, obj_planetGenerator);

TPosX = PosX;
TPosY = PosY;
TScale = Scale;

ScalePrev = Scale;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
FPSOut = "FPS: " + string(floor(fps_real));
alarm[0] = 20;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if (mouse_check_button(mb_right)) {
    if (Drag) {
        TPosX += (mxp - mouse_x) / Scale;
        TPosY += (myp - mouse_y) / Scale;
    } else {
        Drag = true;
    }
    mxp = mouse_x;
    myp = mouse_y;
} else {
    Drag = false;
}

if (mouse_wheel_down( )) {
    PlanetInfo = false;
    NearestI = undefined;
    var new_scale = Scale / 1.3;
    var xx = PosX + mouse_x / Scale;
    var yy = PosY + mouse_y / Scale;
    TPosX = xx - mouse_x / new_scale;
    TPosY = yy - mouse_y / new_scale;
    TScale = new_scale;
}
if (mouse_wheel_up( )) {
    var new_scale = Scale * 1.3;
    var xx = PosX + mouse_x / Scale;
    var yy = PosY + mouse_y / Scale;
    TPosX = xx - mouse_x / new_scale;
    TPosY = yy - mouse_y / new_scale;
    TScale = new_scale;
}

xs = floor(max(0, PosX / CellW - 0.5 - 2));
xf = ceil(min(Width, (PosX + room_width / Scale) / CellW + 2));
ys = floor(max(0, PosY / CellH2 - 2));
yf = ceil(min(Height, (PosY + room_height / Scale) / CellH2 + 2));

if (breaf == noone) {
    if (mouse_check_button_pressed(mb_left)) {
        for (var i = xs; i &lt; xf; i++) {
            for (var j = ys; j &lt; yf; j++) {
                if (VisGrid[#i,j] &amp;&amp; Grid[#i,j] == 2 &amp;&amp; point_distance(mouse_x, mouse_y, getPosX(i, j), getPosY(i, j)) &lt; CellH * Scale) {
                    if (i == x_start &amp;&amp; j == y_start) {
                        breaf = instance_create(0, 0, obj_portalBreaf);
                        SelX = i;
                        SelY = j;
                    } else if (VisGrid[#i,j] == 2) {
                        PlanetInfo = true;
                        NearestI = i;
                        NearestJ = j;
                    } else if (PlanetsAvailable &gt; PlanetsUsed) {
                        VisGrid[#i,j] = 2;
                        for (var d = 0; d &lt; 6; d++) {
                            var xx = i + hex_dx(i, j, d);
                            var yy = j + hex_dy(d);
                            if (xx &gt;= 0 &amp;&amp; xx &lt; Width &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; Height) {
                                VisGrid[#xx,yy] = 2;
                            }
                        }
                        for (var d = 0; d &lt; 12; d++) {
                            var xx = i + hex_ddx(i, j, d);
                            var yy = j + hex_ddy(d);
                            if (xx &gt;= 0 &amp;&amp; xx &lt; Width &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; Height) {
                                VisGrid[#xx,yy] = max(VisGrid[#xx,yy], 1);
                            }
                        }
                        i = xf;
                        j = yf;
                        PlanetsUsed++;
                    }
                }
            }
        }
    }
}

PosX += (TPosX - PosX) / 10;
PosY += (TPosY - PosY) / 10;
Scale += (TScale - Scale) / 10;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
draw_set_color(c_black);
draw_set_alpha(0.5);
draw_rectangle(0, 0, string_width(FPSOut), string_height(FPSOut), false);
draw_set_colour(c_white);
draw_set_alpha(1.0);
draw_text(0, 0, FPSOut);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
var surf = surface_create(room_width, room_height);
surface_set_target(surf);
draw_clear_alpha(c_black, 1);
surface_reset_target( );

if (Scale &gt;= 3 || PlanetInfo) {
    if (ScalePrev &lt; 3 &amp;&amp; is_undefined(NearestI)) {
        NearestI = undefined;
        NearestJ = undefined;
        MinDist = undefined;
        XX = 0;
        YY = 0;
        for (var i = xs; i &lt; xf; i++) {
            for (var j = ys; j &lt; yf; j++) {
                if (VisGrid[#i,j] &amp;&amp; Grid[#i,j] == 2) {
                   // if (VisGrid[#i,j] == 2) {
                        var xx = getPosX(i, j) + PosX * Scale// (i * obj_map.CellW + obj_map.CellSize * (j % 2) + obj_map.CellSize) * obj_map.Scale;
                        var yy = getPosY(i, j) + PosY * Scale// (j * obj_map.CellH2 + obj_map.CellH) * obj_map.Scale;
                        var cam_x = PosX * Scale + room_width / 2;
                        var cam_y = PosY * Scale + room_height / 2;
                        var dist = point_distance(cam_x, cam_y, xx, yy);
                        if (is_undefined(NearestI) || MinDist &gt; dist) {
                            NearestI = i;
                            NearestJ = j;
                            MinDist = dist;
                            XX = xx;
                            YY = yy;
                        }
                   // }
                }
            }
        }
    }
    TPosX = NearestI * obj_map.CellW + obj_map.CellSize * (NearestJ % 2) + obj_map.CellSize - room_width / 2.0 / Scale;
    TPosY = NearestJ * obj_map.CellH2 + obj_map.CellH - room_height / 2.0 / Scale;
    TScale = 3;
}
for (var i = xs; i &lt; xf; i++) {
    for (var j = ys; j &lt; yf; j++) {
        if (VisGrid[#i,j] &amp;&amp; Grid[#i,j] == 2) {
            var xx = getPosX(i, j);
            var yy = getPosY(i, j);
            if (VisGrid[#i,j] == 2) {
                surface_set_target(surf);
                draw_set_blend_mode(bm_max);
                draw_circle_colour(xx, yy, CellH * 5 * Scale, c_white, c_black, false);
                draw_set_blend_mode(bm_normal);
                surface_reset_target( );
            }
            if (Scale &gt; 0.5) {
                surface_set_target(obj_planetGenerator.Out);
                draw_clear_alpha(c_black, 0);
                draw_set_color(c_white);
                d3d_set_culling(true);
                random_set_seed(i * Width + j);
                d3d_transform_add_rotation_z(current_time * random_range(-0.1, 0.1) + (i * Width + j) * 1000);
                d3d_transform_add_rotation_x(90);
                //d3d_transform_add_scaling(0.2, 0.2, 0.2);
                var sc = CellH * Scale / 256;
                d3d_transform_add_scaling(sc, sc, sc);
                d3d_transform_add_translation(xx, yy, 0);
                d3d_draw_ellipsoid(-256, -256, -256, 256, 256, 256, surface_get_texture(obj_planetGenerator.Surf), 1, 1, floor(sqrt(Scale) * 16));
                d3d_transform_set_identity( );
                d3d_set_culling(false);
                surface_reset_target( );
            } else {
                random_set_seed(i * Width + j);
                draw_set_color(make_colour_rgb(floor(random(1) * 256), floor(random(1) * 256), floor(random(1) * 256)));
                draw_circle(xx, yy, CellH * Scale, false);
            }
            
            if (VisGrid[#i,j] == 2) {
                for (var d = 0; d &lt; 12; d++) {
                    var xt = i + hex_ddx(i, j, d);
                    var yt = j + hex_ddy(d);
                    if (xt &gt;= 0 &amp;&amp; xt &lt; Width &amp;&amp; yt &gt;= 0 &amp;&amp; yt &lt; Height) {
                        if (Grid[#xt,yt] == 2) {
                            draw_set_color(c_green);
                            draw_line_width(xx, yy, getPosX(xt, yt), getPosY(xt, yt), 2);
                        }
                    }
                }
            }

            if (Scale &gt; 0.5) {
                random_set_seed(i * Width + j);
                shader_set(glsl_earth);
                shader_set_uniform_f(obj_planetGenerator.u_clWater, random(1), random(1), random(1), 1);
                shader_set_uniform_f(obj_planetGenerator.u_clBeach, random(1), random(1), random(1), 1);
                shader_set_uniform_f(obj_planetGenerator.u_clForest, random(1), random(1), random(1), 1);
                shader_set_uniform_f(obj_planetGenerator.u_clMount, random(1), random(1), random(1), 1);
                draw_surface(obj_planetGenerator.Out, 0, 0);
                shader_reset( );
            }

        }
    }
}

shader_set(glsl_light);
draw_surface(surf, 0, 0);
shader_reset( );

surface_free(surf);

ScalePrev = Scale;

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
